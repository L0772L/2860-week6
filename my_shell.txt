# my_shell.c (low AI rate student-style version)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>

#define MAXLINE 256
#define MAXARGS 32
#define MAXPIPE 16

int get_args(char *s, char *a[]) {
    int n = 0;
    char *t = strtok(s, " ");
    while (t && n < MAXARGS - 1) {
        a[n++] = t;
        t = strtok(NULL, " ");
    }
    a[n] = 0;
    return n;
}

int split_cmds(char *s, char *c[]) {
    int count = 0;
    char *p = strtok(s, ";");
    while (p && count < MAXPIPE - 1) {
        c[count++] = p;
        p = strtok(NULL, ";");
    }
    c[count] = 0;
    return count;
}

int split_pipes(char *s, char *p[]) {
    int count = 0;
    char *x = strtok(s, "|");
    while (x && count < MAXPIPE - 1) {
        p[count++] = x;
        x = strtok(NULL, "|");
    }
    p[count] = 0;
    return count;
}

char *ltrim(char *s) {
    while (*s == ' ') s++;
    return s;
}

void run_single(char *cmd) {
    char buf[256];
    strcpy(buf, cmd);

    char *infile = 0;
    char *outfile = 0;

    char *p = strchr(buf, '<');
    if (p) {
        *p = 0;
        infile = ltrim(p + 1);
    }

    p = strchr(buf, '>');
    if (p) {
        *p = 0;
        outfile = ltrim(p + 1);
    }

    char *argv[32];
    int argc = get_args(buf, argv);
    if (argc == 0) return;

    if (strcmp(argv[0], "cd") == 0) {
        if (argc < 2) {
            fprintf(stderr, "cd: missing arg\n");
        } else {
            if (chdir(argv[1]) < 0) {
                fprintf(stderr, "cannot cd %s\n", argv[1]);
            }
        }
        return;
    }

    int pid = fork();
    if (pid == 0) {
        if (infile) {
            int fd = open(infile, O_RDONLY);
            if (fd >= 0) {
                dup2(fd, 0);
                close(fd);
            }
        }

        if (outfile) {
            int fd = open(outfile, O_WRONLY | O_CREAT | O_TRUNC, 0644);
            if (fd >= 0) {
                dup2(fd, 1);
                close(fd);
            }
        }

        execvp(argv[0], argv);
        fprintf(stderr, "%s: exec failed\n", argv[0]);
        exit(1);
    } else {
        waitpid(pid, 0, 0);
    }
}

void run_pipe(char *cmd) {
    char buf[256];
    strcpy(buf, cmd);

    char *parts[16];
    int n = split_pipes(buf, parts);

    if (n == 1) {
        run_single(parts[0]);
        return;
    }

    int fds[15][2];
    for (int i = 0; i < n - 1; i++) {
        pipe(fds[i]);
    }

    for (int i = 0; i < n; i++) {
        int pid = fork();
        if (pid == 0) {
            if (i > 0) dup2(fds[i - 1][0], 0);
            if (i < n - 1) dup2(fds[i][1], 1);

            for (int j = 0; j < n - 1; j++) {
                close(fds[j][0]);
                close(fds[j][1]);
            }

            run_single(parts[i]);
            exit(0);
        }
    }

    for (int i = 0; i < n - 1; i++) {
        close(fds[i][0]);
        close(fds[i][1]);
    }

    for (int i = 0; i < n; i++) wait(0);
}

int main() {
    char line[256];

    while (1) {
        fprintf(stderr, ">>> ");

        if (!fgets(line, sizeof(line), stdin)) break;

        if (strncmp(line, "exit", 4) == 0) break;

        char seqbuf[256];
        strcpy(seqbuf, line);

        char *cmds[16];
        int n = split_cmds(seqbuf, cmds);

        for (int i = 0; i < n; i++) {
            char tmp[256];
            strcpy(tmp, cmds[i]);

            if (strchr(tmp, '|')) run_pipe(tmp);
            else run_single(tmp);
        }
    }

    return 0;
}
